1.将50万条用户数据通过智能合约存储到以太坊上，有何思路？

eg：首先可以从数据的用途上来进行考虑。考虑要保存的数据日后是用来查询展示还是仅仅作为验证信息使用。如果数据仅仅是作为存证使用，则可以考虑将用户数据进行哈希处理后存储到链上，日后用作校证使用。如果是日后需要使用的数据，则可以考虑对数据进行分类处理，比如一些大的数据如图片，文件等，放到专门的文件系统中，比如IPFS上，而把核心的用户数据存放于以太坊链上。

2.说一下LevelDB数据库。

**LevelDB是一个由Google编写的快速键值存储库，它提供了从字符串键到字符串值的有序映射。**

LevelDB的特点：

- 键和值是任意字节数组
- 按键排序存储数据
- 调用者可以提供自定义比较功能来覆盖排序顺序。
- LevelDB基本的操作是`put(key,value)`,`Get(key)`,`Delete(key)`。
- 可以在一个原子批次中进行多项修改。
- 用户可以创建临时快照以获得一致的数据视图。
- 数据支持前向和后向迭代。
- 使用［Snappy压缩库］自动压缩数据。
- 外部活动（文件系统操作等）通过虚拟接口中继，因此用户可以自定义操作系统交互。

当然，LevelDB数据库也有一些限制：

- LevelDB不是关系型数据库，不像MySql那样，所以不支持SQL查询，也不支持索引。
- LevelDB只有一个进程（可能是多线程），可以一次访问特定的数据库。

- 内置于库中的客户端－服务器支持。需要此类支持的应用程序必须在库周围包围自己的服务器。


3.说一下发布一个Token的流程，中间要经历哪些过程？

eg：在以太坊网络中，允许用户自定义发行自己的Token。在发行Token时，要遵循以太坊的Token标准，最常见的是EIP20标准，该标准要求用户在发行自己的代币时，要继承以太坊的EIP20Token标准接口，其中主要的内容包括name，symbol，totalSupply，decimals四个变量；

另外还必须实现一些方法接口有：

- balanceOf（address）：某个地址的余额。
- transfer(address _to, uint256 _value)：转账到某个地址。
- transferFrom（from，to，value）：从某个地址转账到某个地址。
- approve（spender，value），allowance(spender,value)：允许从spender中还能转转账的数量。
- event Transfer(from,to,value)：转账完成后触发该方法。
- event Approval(owner,spender,value)：approval方法调用成功后触发该方法。

我们可以在在线编辑器remix中编写如上的程序，按照如上标准进行继承和实现后，就可以在线通过Remix编译部署到以太坊的测试网络或者主网；在部署过程中，需要借助的一个浏览器插件metamask，来执行智能合约的部署。

4.冷钱包和热钱包有什么区别？Imtoken钱包的信息是存储在哪里的？

eg：在平时的使用当中，最常用的就是imtoken，imtoken作为一个第三方的钱包服务商，就是热钱包。其实呢，从大的角度来说，冷钱包倾向于被认为就是不连接互联网的钱包，因为不和互联网连接，因此，软件本身被攻击的可能性就没有了，大大增加了钱包资产的安全性；热钱包就是会直接和互联网相连接，可以随时和网络上的其他账户或者地址进行转账交易，这种方式对于经常需要进行转账的需求来说，比较方便，但是相应的风险也比不联网的冷钱包要大，因为存在软件钱包或者其所在的设备被黑客攻击的危险。imtoken钱包在进行使用时，有两种基本的功能就是新建钱包和导入钱包；新建钱包需要用户输入钱包密码，然后钱包生成成功后，会提示并要求用户对钱包进行备份，对普通用户来说，最常见的备份方式就是助记词备份，另外还有私钥备份，或者keystore备份；设置的密码会保存在imtoken本地数据，在进行转账时首先进行密码校验，然后再执行转账。

5.以太坊的地址，私钥，助记词之间的关系是怎么样的。

eg：**首先说私钥：**私钥本质上就是一串随机数产生的，比特币和以太坊的私钥都是64位长度的十六进制数字串，私钥的生成完全是随机的，随机生成的字符所有的可能性为16的64次方种，该数要比全宇宙中的原子个数还要多。因此，仅存在理论上重复的可能性，完全没有实际可被重复的可能。

**关于地址：**地址是由公钥通过一系列计算而得出的一串字符串。在地址生成的过程中，首先第一步要产生的就是利用算法API生成一个私钥，然后私钥通过计算能够得到一个对应的公钥，再由公钥通过计算最后生成地址。

**比特币的地址生成过程：**比特币种的地址生成用到了密码学算法，采用的算法是椭圆加密算法（ECDSA）来产生比特币的私钥和公钥，再由公钥值经过一系列的数字签名计算等得到比特币地址。

1. 第一步，使用ECDSA.cipher()方法产生一个椭圆方程，然后生成一个64位的串，该16进制的64位字符串就作为私钥。
2. 使用椭圆曲线加密算法(ECDSA-secep256k1)计算私钥所对应的公钥。公钥共65个字节，第一个字节位0x04，32字节位x坐标，32字节为y坐标。
3. 将公钥通过SHA－256计算，得到哈希值。
4. 取SHA－256计算后的哈希值，经过RIPEMD－160计算，得到哈希值。
5. 拿到第四步的哈希值结果，在哈希值前面加上地址版本号，比特币主网的版本号是“0x00”。记作A串。
6. 将加上了版本号的哈希值继续进行SHA－256哈希计算，得到哈希值。
7. 将得到的结果继续进行SHA－256哈希计算，再次得到哈希值。
8. 取经过两次SHA－256计算后的哈希值的前四个字节，记作B串。
9. 将B串添加在第5步操作得到的A串结果后面，作为校验使用。组合后的串记作C串。
10. 使用base58将组合后的C串进行变换展示，最终得到我们最熟悉的比特币的地址。

说明：最常见的比特币的地址就是1开头的一串字符串。有些数字以‘0x’开头，意思是此数字使用16进制表示法。‘0x’本身没有任何的含义，它是C语言流传下来的，约定俗成的写法。另外，1个字节＝8个二进制位＝2个16进制位。

**助记词：**第一步我们知道私钥是随机生成的64位16进制数字表示的串，但是64位的字符串对普通用户而言没有可读性，记忆和存储起来难度较大。因此，人们就想办法通过助记词工具利用某种算法将64位的私钥可以转换成常见的英文单词，这些单词都来源于一个固定词库。因此助记词就是私钥，私钥就是助记词，只是同一种信息的不同表现形式而已。

另外还有其他概念，比如脑钱包：脑钱包的意思就是说用户自己想好一串独有的英文单词，这串英文单词就可以作为自己的私钥。通过一定的算法计算，即可将这一串英文字符转化为64位的私钥和地址。

再说钱包：钱包一般是由第三方软件服务商开发提供给普通用户使用的数字资产管理软件，钱包的功能一般就三个：生成私钥和地址；私钥管理器，提供钱包密码功能，只有拥有密码的的人才能打开钱包；另外的就是接受转账和给别人转账的数字资产转账功能了。

**Keystore：**Keystore 不是私钥，Keystore的本质是加密后的私钥，Keystore的格式是json数据格式。Keystore必须配合钱包密码来使用，所以说，光备份了Keystore但忘记了钱包密码也是无法进行恢复的。

总结就是：私钥就是财富！助记词就是私钥！保管好私钥或者助记词不被泄漏，再或者就是保存好keystore＋记住密码。

6.以太坊上的Nonce值是做什么的？与Bitcoin上的Nonce有何不同？

eg：以太坊的Nonce变量是交易中的一个字段，该Nonce和账户的交易有关系。具体是关系就是Nonce值是随交易的发起账户而决定的，交易的发起账户每次发起一笔交易，该笔交易中的Nonce就会在之前的基础上＋1，Nonce是从0开始的。相比较而言，Bitcoin的Nonce是一个随机的数值，用来争取获得记账权，该Nonce值是要矿工来进行一个一个的进行便利尝试，在达到目标值后，计算出正确Nonce值的矿工进行记账打包，这也是挖矿的过程。

7.以太坊中什么是叔块？是如何产生的？

eg：要说叔块，就必须先说`孤块`。所谓孤块，是在比特币协议中被提出的。在比特币协议中，最长的链被记账节点认可，绝对正确可信任。如果一个块不是最长链的一部分，那么这个块被称为孤块。一个孤立的块是一个块，孤块也是合法的，但是发现的稍晚，或者是网络传输速度慢，从而造成没有能够成为最长链的一部分。在比特币种，孤块没有意义，会被抛弃，发现该孤块的矿工也拿不到奖励。

在以太坊中，有一个GHOST协议，该协议不认为孤块没有价值，相反以太坊系统会给与发现孤块的矿工一定的回报。在以太坊中，孤块就叫做`叔块`，叔块可以为主链的安全做出贡献。叔块的奖励公式：叔块奖励 = （叔块高度＋8－包含叔块的区块的高度）＊普通区块奖励/8。

总结：叔块是以太坊引进的，故名思义叔块就是某个块A跟自己的父区块指向的父区块相同。该A块就称为当前块的叔块。原则是当前块出现时，弱发现有叔块产生，则会把叔块也打包进新的块中。

为什么要有叔块呢？这和以太坊的出块时间设计有关系。在比特币中出块时间间隔平均为10分钟一个块，出现叔块的情况概率比较小，因此在比特币中也没有奖励。但是在以太坊中，缩短了出块时间，大概10s左右就出一个块，则因为网络等原因产生叔块的概率就高了。如果大量的矿工记录了叔块，而得不到奖励，时间长了，矿工的积极性就会降低。

以太坊的wiki文档中描述说，以太坊遵循GHOST协议，如果要打包叔块到区块B的话应该满足几点：

1. 叔块必须是B的第K层祖先。2<=K<=7。
2. 叔块不能是B的祖先。
3. 叔块必须有合法的block header，但是不必是之前验证的完整的block。
4. 叔块必须没有被包进区块过的。

8.以太坊中的挖矿算法是什么？说一下具体是如何工作的？

eg：以太坊中目前使用的算法是PoW算法，下一步有计划会切换到PoS算法。

9.是否了解EOS？以太坊账户和EOS账户有什么区别？

10.对比特币的交易模型有了解吗？详细说一下？和以太坊的交易模型有什么区别？

eg：比特币种的交易模型采用的是UTXO交易模型，所谓UTXO模型就是UnSpent Transaction Output，它是中本聪在比特币白皮书中提出的一种用来解决双花问题的方案。

11.双花是如何产生的？如何解决双花问题？

eg：区块链中每一笔记录都是交易，在交易的过程中，存在一个‘双重支付’的问题，也就是双花的问题。所谓双花问题即是当账户发起一笔交易付款时，在还没有进行交易完成时，立即进行第二笔交易，此时就会产生账户里的钱被用了两次的问题，即为双花。在比特币中，解决双花的方案是进行逐条分析。在比特币系统中，当用户发起交易时，会向全网广播交易信息，同时，附带一条加密信息，这条加密信息是用Hash函数对上一条信息加密生成一个摘要后，再用A的私钥进行加密的（称为私钥签名）。然后由接收到广播信息的B和其他用户先用同样的Hash函数对明文信息生成摘要，再用A的公钥对加密信息进行解密，如果解密得到的摘要与明文生成的摘要相同，便认为信息确实是A发出的，且没有经过篡改。

因此，区块链网络对双花的问题解决方案是：

- 每一笔交易都需要先确认对应比特币（账户）之前的状态，如果它之前就已经被标记为花掉状态，那么新的交易会被拒绝。

- 如果先发起一笔交易，在该笔交易被确认前，也就是这个时间段的交易还未被记账成区块block时，进行矛盾的第二笔交易，那么在记账时，这些后发起的交易会被拒绝。

- 上面两条是基本的原则。如果诈骗者刻意把第一笔交易向一半网络进行广播，把第二笔交易向另一半网络进行广播，这就会导致两遍各自一半矿工刚好同时取得对交易的记账权，把各自的block发布给大家，网络是否会混乱呢？在区块链里面的规则是；先选择任意一个账本都可以，这时候原来统一的账本出现了分叉

  ![image-20180912184409515](/var/folders/_n/0wz2n7dx27gcl3hd2sk1cfth0000gn/T/abnerworks.Typora/image-20180912184409515.png)

  但是在两个账本中鸽子有一笔交易，诈骗者得不到好处。接下来，下一个矿工选择在A的基础上继续记账的话，A分支就会比B分支更长。根据区块链的规则，最长的分支会被认可，短的分支会被放弃，账本还是会回归一个，交易也只有一笔有效。

- 诈骗者再厉害聪明一些，就是在A被记账后，立马自己获得记账权，争取连续两次记账权，然后依次争取获得记账权。在比特币网络中，算历的越大获得记账权的概率越大，因此，如果掌握51%的算力，就能够对交易的数据进行修改，这种攻击方式也称为51%攻击。

12.如何提升节点的TPS？

eg：https://baijiahao.baidu.com/s?id=1605821443717338533&wfr=spider&for=pc。 DistributedHashTable（DHT）和Blockchain的结合在某种程度上可以提高效应。

分片技术。EOS的弱中心。

13.以太坊中是如何校验地址的有效性的？

eg：在进行以太坊地址的有效性判断之前，需要熟悉以太坊的地址规则如下：

1. eth的地址就是把公钥用sha256hash之后，取其后160位，记作A。
2. A串转换成16进制字符串（40个字符），再加上前缀‘0x’

因此，知道了以太坊地址的规则，就可以对以太坊的地址进行校验了，校验规则如下：

1. 先判断地址非空和是否`ox`开头。
2. 把16进制字符串转成10进制数，看是否能够转换成功。
3. 去掉`0x`后，判断长度是否是40位。

14.以太坊交易流程是怎么样的，描述一下？如何做的签名和验签。

eg：在以太坊的代码层面，转账有两个方法可以调用：分别为sendTransaction()和sendRawTransaction()两个方法。

两者的区别在于：

1. sendTransaction方法意味着指定从某个账户发起，而且这个账户一定要在本地的geth中保存有keystore数据文件，该方法无论是在线还是离线都可以使用。核心在于通过geth托管私钥。
2. sendRawTransaction方法是用于构造好的交易通过该接口来进行广播。既然是广播，该方法就说明需要在线状态。

以太坊的网络交易，最终调用的都是上面两个方法中的一种，交易流程其实主要就三个阶段：对数据进行签名；对数据进行验证；以及数据篡改三个阶段。

##### **一，数据签名**

1. 用户传入参数
2. 使用from对应的在geth托管的privatekey与secp256k1算法对要转账的参数签名得出三个变量：V，R，S。
3. 使用RLP（递归长度遍历）方式序列化签名的数据。
4. 发送到ETH节点。

sendRawTransaction函数的参数有：from表示发送者钱包地址；value表示转账数值，单位为wei；gas为油费，该值不是最终使用值，真实为gasUsed；gasPrice油费单价；data为附属的数据，可做智能合约函数入参；nonce交易序列号类似id，和账号有关。

sendTransaction的方法内部会根据用户传递的from字段到节点的accountManager账号管理器中获取from的密钥，从而对数据进行签名。sendTransaction一般不会用于远程调用，而用于本地调用，因为只有在本地启动节点的时候，才能配置我们解锁的钱包。

两者方法签名使用的加密方式是：`非对称加密`中的`secp256k1`椭圆曲线算法。

**非对称加密算法：**

- RSA
- secp2561(椭圆曲线)
- EIGamal

**RLP序列化：**

RLP(递归长度前缀)提供了一种适用于任意二进制数据数组的编码，RLP已经成为以太坊对对象进行序列化的主要编码方式。RLP的唯一目标就是解决结构体的编码问题；对原子数据类型（比如，字符串，整数型，浮点型）的编码则交给更高层的协议；以太坊中要求数字必须是一个大端字节序的，没有零占位的存储的格式。

签名后，数据将会被发送到ETH节点。

##### **二，数据验证**

在第一步已经调用sendRawTransaction方法，会对接到RPC接口。

1. 收到RLP序列化的数据后，先进行RLP的反序列化。
2. 然后进行数据的基础校验，这里的校验主要是一些范围限制以及格式限制校验。
   - tx.size() > 32*102
   - tx.Value().Sign() < 0
   - pool.currrentMaxGas < tx.Gas()

3. `检查签名`，所使用的是`secp256k1.RecoverPubkey`方法，secp256k1本身支持根据签名信息`反推公钥`

用消息和签名推导出对方的公钥。再通过公钥，签名，消息的哈希值计算出一个叫r的值，这个r是签名的一部分，校验签名就是拿计算出来的r和签名中携带的r进行对比，如果一致就校验通过。

##### **三，数据篡改**

因为签名生成的V R S 是由私钥进行签名的，如果修改者只修改了外部的值，例如：value，本来要转10个ETH，被改成转100个，这样等数据传到以太坊节点的时候，在检查签名的时候，就会发现不匹配，报错。

15.